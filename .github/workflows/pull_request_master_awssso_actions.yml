name: Pull Request to Master for AWS SSO
#this action will run on the creation of a pull request to master for any changes to the code that manages the AWS SSO resources, and if the pull request has no label.
#it should perform the following actions:
# -generate/update terraform docs to ensure the documentation remains aligned with the code
# -runs terraform fmt and commits any changes to the source branch to ensure the terraform code remains in a canonical format and style
# -statically analyzes the terraform code for code that would result in "misconfigurations". Currently the results of the analysis are added to a comment in the pull request to inform the approver, but any findings do not block merging
# -performs terraform plan and adds the plan to a comment in the pull request to inform the approver.

on:
  pull_request:
    paths:
     - 'applied/accounts/global/us-east-1/awssso/**'
     - 'infrastructure/region/awssso/**'
     - '!**.md'    # do not run the job when only changing markdown files
     - '.github/**'  #this is only there for testing

env:
  TERRAFORM_VERSION: 1.1.5  # the version of terraform to install in this runner
  TERRAGRUNT_VERSION: 0.36.2 # the version of terragrunt to install in this runner
  ORCHESTRATION_ROLE_ARN: 'arn:aws:iam::119662755212:role/awssso_orchestration_role' #iam-global
  #The orchestration role defined here will assume a state management role defined in the backend.tf and a worker role defined in the provider.tf. 
  #Both of those terraform files are generated by terragrunt so the roles are defined in the terragrunt.hcl file.
  TERRAFORM_WORKING_DIR: './applied/accounts/global/us-east-1/awssso/'  #scoped to only AWS SSO Terraform code
  TERRAFORM_LOCK_HCL_PATH: './applied/accounts/global/us-east-1/awssso/.terraform.lock.hcl' #path to the .terraform.lock.hcl file is required for GitHub Actions to add and commit
  open_pull_request: github.base_ref == 'master' && join(github.event.pull_request.labels.*.name, '') == '' && github.event.action == 'opened'
  merge_pull_request1: github.base_ref == 'master' && join(github.event.pull_request.labels.*.name, '') == '' && github.event.pull_request.merged == true  
  merge_pull_request: ${{ github.base_ref == 'master' && join(github.event.pull_request.labels.*.name, '') == '' && github.event.pull_request.merged == true }} 
  
permissions:
  id-token: write       # write permissions are needed to generate the OIDC token for AWS
  contents: write       # write permissions are needed in order to commit changes back to the branches
  issues: write         # write permissions are needed in order to create comments
  pull-requests: write  # write permissions are needed in order to create comments

concurrency: production  # This will ensure that only a single PR workflow will run at a time to avoid different workflow running terraform plan & apply trying to acquire state lock at the same time causing one to fail

jobs:
  echo:
    runs-on: ubuntu-20.04
    steps:
      - name: echo
        run: |
          echo "open_pull_request: $open_pull_request"
          echo "merge_pull_request: $merge_pull_request"

  docs_awssso:
    name: "Generate Terraform Docs for AWS SSO"
    if: github.base_ref == 'master' && join(github.event.pull_request.labels.*.name, '') == '' && github.event.action == 'opened'
    uses: ./.github/workflows/terraform_docs.yml
    with:
      WORKING_DIRECTORY: 'infrastructure/region/awssso/' #scoped to only AWS SSO Terraform code

  docs_modules:
    name: "Generate Terraform Docs for Modules"
    if: github.base_ref == 'master' && join(github.event.pull_request.labels.*.name, '') == '' && github.event.action == 'opened'
    uses: ./.github/workflows/terraform_docs.yml
    with:
      WORKING_DIRECTORY: 'modules/' #scoped to only Terraform modules

  format:
    name: "Run terraform fmt and push changes back to PR branch"
    if: github.base_ref == 'master' && join(github.event.pull_request.labels.*.name, '') == '' && github.event.action == 'opened'
    uses: ./.github/workflows/terraform_format.yml
    with:
      TERRAFORM_VERSION: 1.1.5

  kics:
    # Kics performs static code analysis of Infrastructure of Code (Terraform).
    # More details can be found here: https://docs.kics.io/latest/
    name: "Run Kics scan on Terraform code"
    if: github.base_ref == 'master' && join(github.event.pull_request.labels.*.name, '') == '' && github.event.action == 'opened'
    uses: ./.github/workflows/terraform_kics.yml
    with:
      # Enabling Comments will add a comment to a PR, but these do no exist in Push events and will throw an error.
      ENABLE_COMMENTS: true
      WORKING_DIRECTORY: 'infrastructure/region/awssso/' #scoped to only AWS SSO Terraform code

  plan:
    name: "Run Terragrunt Init, Validate and Plan"
    #since the format & docs jobs *could* commit changes, wait until those complete before running this job
    needs: [format, docs_awssso, docs_modules]
    #plan job will run if the target branch of the pull request is master,the pull request is not merged and if the pull request does not have a label 
    if: github.base_ref == 'master' && join(github.event.pull_request.labels.*.name, '') == '' && github.event.action == 'opened'
    runs-on: ubuntu-20.04
    defaults:
      run:
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v2
        with:
          # This will checkout the branch the PR is coming from in the head repo to avoid checkoing out repo in a detached state.
          # needed to commit terraform lockfile
          ref: ${{ github.event.pull_request.head.ref }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1.3.2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: true

      - name: Setup Terragrunt
        uses: autero1/action-terragrunt@v1.1.0
        with:
          terragrunt_version: ${{ env.TERRAGRUNT_VERSION }}

      - name: configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1.6.1
        with:
          aws-region: us-east-1
          role-to-assume: ${{ env.ORCHESTRATION_ROLE_ARN }}

      - name: Terragrunt Init
        id: init
        run: terragrunt run-all init -lockfile=readonly -no-color --terragrunt-non-interactive

      - name: Post Init
        uses: robburger/terraform-pr-commenter@v1.5.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EXPAND_SUMMARY_DETAILS: 'true' # Override global environment variable; expand details just for this step
        with:
          commenter_type: init
          commenter_input: ${{ format('{0}{1}', steps.init.outputs.stdout, steps.init.outputs.stderr) }}
          commenter_exitcode: ${{ steps.init.outputs.exitcode }}

      - name: Terragrunt Validate
        id: validate
        run: terragrunt run-all validate -no-color --terragrunt-non-interactive

      - name: Post Validate
        uses: robburger/terraform-pr-commenter@v1.5.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EXPAND_SUMMARY_DETAILS: 'true' # Override global environment variable; expand details just for this step
        with:
          commenter_type: validate
          commenter_input: ${{ format('{0}{1}', steps.validate.outputs.stdout, steps.validate.outputs.stderr) }}
          commenter_exitcode: ${{ steps.validate.outputs.exitcode }}

      - name: commit lock file
        uses: EndBug/add-and-commit@v9
        with:
          add: ${{ env.TERRAFORM_LOCK_HCL_PATH }} # path to the .terraform.lock.hcl file is required for GitHub Actions to add and commit
          message: "fix:Persisting lock file"
          push: true
          
      - name: Terragrunt Plan
        id: plan
        run: | # did this in 2 steps in order to strip the refreshing state... from the plan variables
          terragrunt run-all plan -no-color --terragrunt-non-interactive >/dev/null -out=tfplan
          terragrunt show tfplan

      # This will set a hard limit of 65536 characters for the plan that is sent to the terraform-pr-commenter action.
      - name: Format plan
        id: formatplan
        run: |
          plan=$(cat <<'EOF'
          ${{ format('{0}{1}', steps.plan.outputs.stdout, steps.plan.outputs.stderr) }}
          EOF
          )
          echo "PLAN<<EOF" >> $GITHUB_ENV
          echo "${plan:0:65536}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Post Plan
        uses: robburger/terraform-pr-commenter@v1.5.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EXPAND_SUMMARY_DETAILS: 'true' # Override global environment variable; expand details just for this step
        with:
          commenter_type: plan
          commenter_input: ${{ env.PLAN }}
          commenter_exitcode: ${{ steps.plan.outputs.exitcode }}

  apply:
    name: "Run Terragrunt Apply"
    #apply job will run if master is the target branch of the pull request,closed by merging to master and,if the pull request does not have a label
    if: github.base_ref == 'master' && github.event.pull_request.merged == true && join(github.event.pull_request.labels.*.name, '') == ''
    runs-on: ubuntu-20.04
    defaults:
      run:
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1.3.2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: true

      - name: Setup Terragrunt
        uses: autero1/action-terragrunt@v1.1.0
        with:
          terragrunt_version: ${{ env.TERRAGRUNT_VERSION }}

      - name: configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1.6.1
        with:
          aws-region: us-east-1
          role-to-assume: ${{ env.ORCHESTRATION_ROLE_ARN }}

      - name: Terragrunt Init
        id: init
        run: terragrunt run-all init -lockfile=readonly -no-color --terragrunt-non-interactive

      - name: Terragrunt Apply
        id: apply
        #this is doing a plan by design for now.
        #after merging to master and testing the plan works, we'll create another PR to change this to apply
        run: terragrunt run-all apply -no-color --terragrunt-non-interactive
        continue-on-error: true